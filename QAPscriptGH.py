'''
QAP Tool for 2 to 10 Departments
Authors: Brent Thames & Ryan Griffeth

****** READ ME BEFORE RUNNING ******
You need to enter your Gurobi credentials on lines 244-246.
Flow matrix 'f', facility dimensions 'space', and department areas 'a' must follow
the same format as the provided test cases.
'f' can be asymmetric OR upper triangular.
The distance matrix is generated by make_distance_matrix_2d() based on 'space',
i.e., explicitly defined distance matrices are not currently supported.
'''

import turtle
from collections import deque

import gurobipy as gp
from gurobipy import GRB, quicksum

'''
# TEST CASES: 

#6 dept test case - optimal cost unknown
f = [[0, 3, 1, 0, 2, 4],   
     [0, 0, 5, 0, 1, 0],   
     [0, 0, 0, 4, 2, 0],   
     [0, 0, 0, 0, 0, 3],   
     [0, 0, 0, 0, 0, 1],   
     [0, 0, 0, 0, 0, 0]]
space = [2, 3]       
a     = [1,1,1,1,1,1] 

#5 Dept test case w/ Asymmetric Flows
#Chat says there are 4 equally optimal assignments all w/ cost = 46
f = [[0, 4, 1, 0, 0],   # A→B=4
     [3, 0, 0, 5, 0],   # B→A=3 etc.
     [2, 1, 0, 2, 3],   
     [1, 2, 1, 0, 1],   
     [1, 6, 1, 1, 0]]
space = [2, 3]  
a = [1, 1, 1, 1, 1]

#7 Department test case - Cost = 291, LB = 237
f = [[0, 10, 15, 20, 6, 7, 8],
     [0, 0,  10,  5, 4, 4, 4],
     [0, 0,  0,   5, 2, 4, 6],
     [0, 0,  0,   0, 6, 8, 3],
     [0, 0,  0,   0, 0, 8, 3],
     [0, 0,  0,   0, 0, 0, 3],
     [0, 0,  0,   0, 0, 0, 0]]
a = [5, 5, 5, 5, 5, 5, 5]
space = [5, 7]
'''

#4 Dept test case from slides - Cost = 29, LB = 27
f = [[0, 2, 10, 1],
     [0, 0,  4, 2],
     [0, 0,  0, 5],
     [0, 0,  0, 0]]

a = [1, 1, 1, 1]

space = [2, 2]

# Helper: builds Manhattan distance matrix for 2D grid locations
def make_distance_matrix_2d(locs):
    """
    locs: list of (row, col) tuples
    returns D where D[i][j] = Manhattan distance between locs[i] and locs[j]
    """
    n = len(locs)
    D = [[0]*n for _ in range(n)]
    for i, (r1, c1) in enumerate(locs):
        for j, (r2, c2) in enumerate(locs):
            D[i][j] = abs(r1 - r2) + abs(c1 - c2)
    return D

def Hybrid(F, S):
    n = len(F)
    if n < 2 or n > 10:
        raise ValueError("Only 2 ≤ n ≤ 10 departments supported")
    return QAP(F, S)

def flood_fill_allocation(rows, cols, departments, allocations):
    grid = [[None for _ in range(cols)] for _ in range(rows)]
    order = []
    directions = [(-1,0),(1,0),(0,-1),(0,1)]

    def find_next_empty():
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] is None:
                    return (r, c)
        return None

    def find_empty_components():
        visited = [[False]*cols for _ in range(rows)]
        comps = []
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] is None and not visited[r][c]:
                    comp = []
                    dq = deque([(r,c)])
                    visited[r][c] = True
                    while dq:
                        rr, cc = dq.popleft()
                        comp.append((rr, cc))
                        for dr, dc in directions:
                            nr, nc = rr+dr, cc+dc
                            if (0 <= nr < rows and 0 <= nc < cols and
                                grid[nr][nc] is None and not visited[nr][nc]):
                                visited[nr][nc] = True
                                dq.append((nr, nc))
                    comps.append(comp)
        return comps

    n = len(departments)
    for idx, (dept, count) in enumerate(zip(departments, allocations)):
        if idx < n - 1:
            # same two-phase BFS + scan for all but last
            start = find_next_empty()
            if not start:
                print(f"⚠️  Out of space for '{dept}'")
                break

            bfs_vis = {start}
            dq = deque([start])
            filled = 0
            while dq and filled < count:
                r, c = dq.popleft()
                if grid[r][c] is None:
                    grid[r][c] = dept
                    order.append((r, c))
                    filled += 1
                for dr, dc in directions:
                    nbr = (r+dr, c+dc)
                    if (0 <= nbr[0] < rows and 0 <= nbr[1] < cols
                            and nbr not in bfs_vis):
                        bfs_vis.add(nbr)
                        dq.append(nbr)

            # fallback scan
            while filled < count:
                cell = find_next_empty()
                if not cell:
                    print(f"⚠️  Only filled {filled}/{count} for '{dept}'")
                    break
                rr, cc = cell
                grid[rr][cc] = dept
                order.append((rr, cc))
                filled += 1

        else:
            # LAST department: find a component ≥ count
            comps = find_empty_components()
            comp = next((c for c in comps if len(c) >= count), None)
            filled = 0

            if comp:
                # BFS within that component
                bfs_vis = {comp[0]}
                dq = deque([comp[0]])
                while dq and filled < count:
                    r, c = dq.popleft()
                    if grid[r][c] is None:
                        grid[r][c] = dept
                        order.append((r, c))
                        filled += 1
                    for dr, dc in directions:
                        nbr = (r+dr, c+dc)
                        if nbr in comp and nbr not in bfs_vis:
                            bfs_vis.add(nbr)
                            dq.append(nbr)

            # if still short (or no comp), fallback scan
            while filled < count:
                cell = find_next_empty()
                if not cell:
                    print(f"⚠️  Only filled {filled}/{count} for '{dept}'")
                    break
                rr, cc = cell
                grid[rr][cc] = dept
                order.append((rr, cc))
                filled += 1

    return grid, order

def draw_grid(t, rows, cols, size):
    width = cols * size
    height = rows * size
    start_x = -width / 2
    start_y = height / 2

    t.color("lightgray")
    t.penup()
    for i in range(cols + 1):
        x = start_x + i * size
        t.goto(x, start_y)
        t.setheading(-90)
        t.pendown()
        t.forward(height)
        t.penup()
    for i in range(rows + 1):
        y = start_y - i * size
        t.goto(start_x, y)
        t.setheading(0)
        t.pendown()
        t.forward(width)
        t.penup()

def get_cell_center(r, c, rows, cols, size):
    start_x = -cols * size / 2 + size / 2
    start_y = rows * size / 2 - size / 2
    x = start_x + c * size
    y = start_y - r * size
    return (x, y)

def label_departments(t, grid, rows, cols, size):
    t.penup()
    t.color("black")
    t.hideturtle()
    t.speed(0)
    for r in range(rows):
        for c in range(cols):
            label = grid[r][c]
            if label:
                x, y = get_cell_center(r, c, rows, cols, size)
                t.goto(x, y - 5)
                t.write(label, align="center", font=("Arial", 16, "normal"))

def draw_traversal_path(t, path, rows, cols, size):
    t.color("#add8e6")
    t.penup()
    for idx, (r, c) in enumerate(path):
        x, y = get_cell_center(r, c, rows, cols, size)
        if idx == 0:
            t.goto(x, y)
            t.pendown()
        else:
            t.goto(x, y)
            
def QAP(F, S):
    options = {
    "WLSACCESSID": "######",
    "WLSSECRET": "######",
    "LICENSEID": 0101010}
    
    rows, cols = S
    n = len(F)
    if n > rows * cols:
        raise ValueError(f"Grid size {rows}x{cols} too small for {n} departments")

    # Choose first n locations in row-major order
    locs = [(i // cols, i % cols) for i in range(n)]
    D2 = make_distance_matrix_2d(locs)

    model = gp.Model(f"QAP{n}_2D")
    x = model.addVars(n, n, vtype=GRB.BINARY, name="x")  # x[i, k]: dept i → location k

    # Objective: sum F[i][j] * D2[k][l] * x[i,k] * x[j,l]
    model.setObjective(
        quicksum(F[i][j] * D2[k][l] * x[i, k] * x[j, l]
                 for i in range(n) for j in range(n)
                 for k in range(n) for l in range(n)),
        GRB.MINIMIZE)

    # Constraints: one dept per location and one location per dept
    for i in range(n):
        model.addConstr(quicksum(x[i, k] for k in range(n)) == 1)
    for k in range(n):
        model.addConstr(quicksum(x[i, k] for i in range(n)) == 1)

    model.optimize()

    # Format output
    depts = [chr(ord('A') + i) for i in range(n)]
    result = [["Objective", round(model.ObjVal, 2)]]
    for i, name in enumerate(depts):
        result.append([name] + [int(x[i, k].X) for k in range(n)])
    return result

returnlist = Hybrid(f, space)
print(returnlist)

departments = []
allocations = []  # Must total ≤ rows * cols

# loops to save departments to locations *** puts QAP()'s results in departments[] and allocations[]
#                                            so flood_fill_allocation() can use it to draw output grid ***
i = 0
while i < len(f):
    j = 0
    while j < len(f):
        if returnlist[j+1][i+1] == 1:
            departments.append(returnlist[j+1][0])
            allocations.append(a[j])
        j = j + 1
    i = i + 1

rows = space[0]
cols = space[1]
size = 100  # Size of each cell

if sum(allocations) > rows*cols:
    print("Error: Not Enough Space Available")
    
# Setup
screen = turtle.Screen()
draw = turtle.Turtle()
draw.speed(0)
draw.pensize(5)

# Draw grid
draw_grid(draw, rows, cols, size)

# Allocate and get traversal path
grid, path = flood_fill_allocation(rows, cols, departments, allocations)

# Draw the traversal curve
draw_traversal_path(draw, path, rows, cols, size)

# Label cells with department names
labeler = turtle.Turtle()
label_departments(labeler, grid, rows, cols, size)

# Finish
draw.hideturtle()
screen.mainloop()